<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>call</title>
</head>
<body>
<input type="text" id="idTxt" value="input text">

<h1>fun.call(thisArg[, arg1[, arg2[, …]]])</h1>
<ul>
    <li>    call()作用都是改变当前作用域，即改变this的指向，将函数对象从初始的上下文改变为由thisArg指定的新对象。</li>
    <li>    thisArg：可选项，将被当做当前对象。如果没有thisArg，那么global对象将被用作thisArg.</li>
    <li>    arg1,arg2：可选项，将被传递方法参数序列。</li>
</ul>

<script>
    //    demo1
    //    var value = "global var";
    //    function mFunc(){
    //        this.value = "member var";
    //    }
    //    function gFunc(){
    //        alert(this.value);
    //    }
    //    window.gFunc(); //=>global var
    //    gFunc.call(window); //=>global var
    //    gFunc.call(new mFunc()); //=>member var
    //    gFunc.call(document.getElementById('idTxt')); //=>input text


    //    demo2
    //func调用的作用域是func，那么this指向func，this.a就等于func,对于第二个alert(x)，func2()的参数为func2,所以alert(x)=>’func2’
//    var func = new function () {
//        this.a = "func";
//    }
//    var func2 = function (x) {
//        var a = "func2";
//        alert(this.a); //=>'func'
//        alert(x); //=>'func2'
//    }
//    func2.call(func, "func2");


//    demo3
//    var animals = [
//        { species: 'Lion', name: 'King' },
//        { species: 'Whale', name: 'Fail' }
//    ];
////    for (var i = 0; i < animals.length; i++) {
////        (function(i) {
////            this.print = function() {
////                console.log('#' + i + ' ' + this.species + ': ' + this.name);
////            }
////            this.print();
////        }).call(animals[i], i);
////    }
//    for (var i = 0; i < animals.length; i++) {
//        var callFunc = function(i) {
//            this.print = function() {
//                console.log('#' + i + ' ' + this.species + ': ' + this.name);
//            }
//            this.print();
//        };
//        callFunc.call(animals[i], i)
//    }
</script>
</body>
</html>